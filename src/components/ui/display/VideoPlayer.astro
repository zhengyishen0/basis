---
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';

const videoPlayerVariants = cva(
  'relative bg-black overflow-hidden max-w-2xl',
  {
    variants: {
      shape: {
        rectangle: 'rounded-none',
        rounded: 'rounded-lg'
      },
      aspectRatio: {
        '16/9': 'aspect-video',
        '4/3': 'aspect-[4/3]',
        '21/9': 'aspect-[21/9]'
      }
    },
    defaultVariants: {
      shape: 'rounded',
      aspectRatio: '16/9'
    }
  }
);

export interface Props extends VariantProps<typeof videoPlayerVariants> {
  // Video source options
  src?: string;
  poster?: string;
  
  // YouTube support
  youtubeId?: string;
  
  // Playback options
  autoplay?: boolean;
  loop?: boolean;
  muted?: boolean;
  
  // Design options
  shape?: 'rectangle' | 'rounded';
  aspectRatio?: '16/9' | '4/3' | '21/9';
  class?: string;
}

const { 
  src,
  poster,
  youtubeId,
  autoplay = false,
  loop = false,
  muted = false,
  shape = 'rounded',
  aspectRatio = '16/9',
  class: className,
  ...alpineProps
} = Astro.props;
---

<!-- VideoPlayer Component based on your beloved test video -->

{youtubeId ? (
  <!-- YouTube Video -->
  <div class={cn(videoPlayerVariants({ shape, aspectRatio }), className)}>
    <iframe 
      src={`https://www.youtube.com/embed/${youtubeId}?enablejsapi=1&controls=1&modestbranding=1&rel=0${autoplay ? '&autoplay=1' : ''}`}
      title="YouTube video player"
      style="border: none;"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowfullscreen
      class="w-full h-full"
    ></iframe>
  </div>
) : (
  <!-- Local Video Player -->
  <div 
    x-data="{
      playing: false,
      muted: false,
      volume: 1,
      currentTime: 0,
      duration: 0,
      buffered: 0,
      loading: true,
      showControls: false,
      
      init() {
        this.video = this.$refs.video;
        
        this.video.addEventListener('loadedmetadata', () => {
          this.duration = this.video.duration;
          this.loading = false;
        });
        
        this.video.addEventListener('timeupdate', () => {
          this.currentTime = this.video.currentTime;
          if (this.video.buffered.length > 0) {
            this.buffered = this.video.buffered.end(this.video.buffered.length - 1);
          }
        });
        
        this.video.addEventListener('play', () => {
          this.playing = true;
        });
        
        this.video.addEventListener('pause', () => {
          this.playing = false;
        });
      },
      
      togglePlay() {
        if (this.playing) {
          this.video.pause();
        } else {
          this.video.play();
        }
      },
      
      toggleMute() {
        this.muted = !this.muted;
        this.video.muted = this.muted;
      },
      
      setVolume(newVolume) {
        this.volume = newVolume;
        this.video.volume = newVolume;
        this.muted = newVolume === 0;
        this.video.muted = this.muted;
      },
      
      formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return mins + ':' + secs.toString().padStart(2, '0');
      },
      
      seekToPercentage(percentage) {
        this.seek(this.duration * percentage / 100);
      },
      
      seek(time) {
        this.video.currentTime = Math.max(0, Math.min(this.duration, time));
      },
      
      getProgressPercentage() {
        return this.duration ? (this.currentTime / this.duration) * 100 : 0;
      },
      
      getBufferedPercentage() {
        return this.duration ? (this.buffered / this.duration) * 100 : 0;
      }
    }"
    class={cn(videoPlayerVariants({ shape, aspectRatio }), className)}
    @mouseenter="showControls = true"
    @mouseleave="showControls = false"
    {...alpineProps}
  >
    <!-- Video -->
    <video
      x-ref="video"
      class="w-full h-full object-contain cursor-pointer"
      poster={poster}
      autoplay={autoplay}
      loop={loop}
      muted={muted}
      @click="togglePlay()"
    >
      {src && <source src={src} type="video/mp4" />}
      Your browser does not support the video tag.
    </video>
    
    <!-- Loading -->
    <div x-show="loading" class="absolute inset-0 flex items-center justify-center bg-black/50">
      <div class="text-white">Loading...</div>
    </div>
    
    <!-- Center Play Button -->
    <div x-show="!playing && !loading" class="absolute inset-0 flex items-center justify-center">
      <button 
        @click="togglePlay()"
        class="bg-black/50 hover:bg-black/70 text-white rounded-full p-4 transition-all duration-200 hover:scale-110"
      >
        <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24">
          <path d="M8 5v14l11-7z"/>
        </svg>
      </button>
    </div>
    
    <!-- Controls with Gradient Background -->
    <div 
      class="absolute inset-x-0 bottom-0 bg-gradient-to-t from-black/80 to-transparent p-2 transition-opacity duration-200" 
      :class="showControls ? 'opacity-100' : 'opacity-0'"
    >
      <!-- Progress Bar -->
      <div class="mb-2 px-2"
        x-data="{ 
          hovered: false, 
          dragging: false,
          dragProgress: 0,
          
          handleMouseDown(e) {
            this.dragging = true;
            const boundMouseMove = this.handleMouseMove.bind(this);
            const boundMouseUp = this.handleMouseUp.bind(this);
            document.addEventListener('mousemove', boundMouseMove);
            document.addEventListener('mouseup', boundMouseUp);
            this.boundMouseMove = boundMouseMove;
            this.boundMouseUp = boundMouseUp;
            e.preventDefault();
            // Calculate initial position
            this.updateProgressFromMouse(e);
          },
          
          handleMouseMove(e) {
            if (!this.dragging) return;
            this.updateProgressFromMouse(e);
          },
          
          updateProgressFromMouse(e) {
            const rect = this.$refs.progressTrack.getBoundingClientRect();
            const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            
            // Update drag progress immediately for UI
            this.dragProgress = pos * 100;
            
            // Update video position directly (Pine's approach)
            if (this.duration > 0) {
              const newTime = pos * this.duration;
              this.video.currentTime = newTime;
              // Also update our currentTime immediately for timestamp display
              this.currentTime = newTime; 
            }
          },
          
          handleMouseUp() {
            this.dragging = false;
            document.removeEventListener('mousemove', this.boundMouseMove);
            document.removeEventListener('mouseup', this.boundMouseUp);
          },
          
          getCurrentProgress() {
            return this.dragging ? this.dragProgress : this.getProgressPercentage();
          }
        }" 
        @mouseenter="hovered = true" 
        @mouseleave="hovered = false"
      >
        <div 
          x-ref="progressTrack"
          class="relative cursor-pointer h-1"
          @click="updateProgressFromMouse($event)"
        >
          <!-- Background Track -->
          <div class="absolute inset-0 bg-white/30 rounded-full"></div>
          
          <!-- Buffered Progress -->
          <div 
            class="absolute inset-y-0 left-0 bg-white/50 rounded-full"
            :style="`width: ${getBufferedPercentage()}%`"
          ></div>
          
          <!-- Current Progress -->
          <div 
            class="absolute inset-y-0 left-0 bg-white rounded-full"
            :style="`width: ${getCurrentProgress()}%`"
          ></div>
          
          <!-- Circle Handle -->
          <div 
            class="absolute top-1/2 transform -translate-y-1/2 w-4 h-4 bg-white rounded-full shadow-lg cursor-grab"
            :class="[(hovered || dragging) ? 'opacity-100 scale-100' : 'opacity-0 scale-75', dragging ? 'cursor-grabbing' : 'cursor-grab', dragging ? '' : 'transition-all duration-200']"
            :style="`left: calc(${getCurrentProgress()}% - 8px)`"
            @mousedown="handleMouseDown($event)"
          ></div>
        </div>
      </div>
      
      <!-- Controls -->
      <div class="flex items-center justify-between">
        <div class="flex items-center space-x-4 pl-2">
          <!-- Play/Pause -->
          <button 
            @click="togglePlay()"
            class="text-white hover:text-gray-300 p-2 rounded"
          >
            <svg x-show="!playing" class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
              <path d="M8 5v14l11-7z"/>
            </svg>
            <svg x-show="playing" class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
              <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
            </svg>
          </button>
          
          <!-- Time Display -->
          <div class="text-white text-sm font-mono">
            <span x-text="formatTime(currentTime)">0:00</span>
            <span class="text-white/60"> / </span>
            <span x-text="formatTime(duration)">0:00</span>
          </div>
        </div>
        
        <!-- Volume Control -->
        <div class="flex items-center pr-4" x-data="{ volumeHovered: false }" @mouseenter="volumeHovered = true" @mouseleave="volumeHovered = false">
          <!-- Volume Icon -->
          <button 
            @click="toggleMute()"
            class="text-white hover:text-gray-300 p-2 rounded"
          >
            <svg x-show="!muted && volume > 0.5" class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
              <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
            </svg>
            <svg x-show="!muted && volume <= 0.5 && volume > 0" class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
              <path d="M18.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM5 9v6h4l5 5V4L9 9H5z"/>
            </svg>
            <svg x-show="muted || volume === 0" class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
              <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
            </svg>
          </button>
          
          <!-- Volume Slider -->
          <div 
            class="w-20 transition-opacity duration-200"
            :class="volumeHovered ? 'opacity-100' : 'opacity-70'"
            x-data="{
              volumeDragging: false,
              
              handleVolumeMouseDown(e) {
                this.volumeDragging = true;
                const boundVolumeMouseMove = this.handleVolumeMouseMove.bind(this);
                const boundVolumeMouseUp = this.handleVolumeMouseUp.bind(this);
                document.addEventListener('mousemove', boundVolumeMouseMove);
                document.addEventListener('mouseup', boundVolumeMouseUp);
                this.boundVolumeMouseMove = boundVolumeMouseMove;
                this.boundVolumeMouseUp = boundVolumeMouseUp;
                e.preventDefault();
                // Update initial position
                this.updateVolumeFromMouse(e);
              },
              
              handleVolumeMouseMove(e) {
                if (!this.volumeDragging) return;
                this.updateVolumeFromMouse(e);
              },
              
              updateVolumeFromMouse(e) {
                const rect = this.$refs.volumeTrack.getBoundingClientRect();
                const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                this.setVolume(pos);
              },
              
              handleVolumeMouseUp() {
                this.volumeDragging = false;
                document.removeEventListener('mousemove', this.boundVolumeMouseMove);
                document.removeEventListener('mouseup', this.boundVolumeMouseUp);
              }
            }"
          >
            <div 
              x-ref="volumeTrack"
              class="relative h-1 bg-white/30 rounded-full cursor-pointer"
              @click="updateVolumeFromMouse($event)"
            >
              <!-- Volume Progress -->
              <div 
                class="absolute inset-y-0 left-0 bg-white rounded-full"
                :style="`width: ${volume * 100}%`"
              ></div>
              
              <!-- Volume Handle -->
              <div 
                class="absolute top-1/2 transform -translate-y-1/2 w-3 h-3 bg-white rounded-full shadow-lg cursor-grab"
                :class="volumeDragging ? 'cursor-grabbing' : 'cursor-grab'"
                :style="`left: calc(${volume * 100}% - 6px)`"
                @mousedown="handleVolumeMouseDown($event)"
              ></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
)}

<!-- 
Usage Examples:

Local Video:
<VideoPlayer 
  src="/video.mp4"
  poster="/poster.jpg"
  shape="rounded"
  aspectRatio="16/9"
  autoplay={true}
/>

YouTube Video:
<VideoPlayer 
  youtubeId="dQw4w9WgXcQ"
  shape="rectangle"
  aspectRatio="21/9"
  autoplay={true}
/>
-->